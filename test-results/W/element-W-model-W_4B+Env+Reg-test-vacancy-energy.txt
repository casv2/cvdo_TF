Model W_4B+Env+Reg, Test vacancy-energy
Test run at 2018-09-06 12:14

model file: ../../../models/W/W_4B+Env+Reg/model.py
============================================================
import juliaimport
import julip
import os

model_dir = os.path.dirname(os.path.realpath(__file__))
IP = juliaimport.import_IP(model_dir + "/W-PIP-B4+Env+Reg.jld2")

#IP = juliaimport.import_IP(os.path.realpath(__file__)[0:-8] + "Ti_4B_med.json")
ASE_IP = julip.JulipCalculator("IP")

calculator = ASE_IP

no_checkpoint = True

name = 'PIP'
============================================================
test file: ../../../tests/W/vacancy-energy/test.py
============================================================
# This script defines a test case which computes one or more physical
# properties with a given model
#
# INPUTS:
#   model.calculator -- an ase.calculator.Calculator instance
#     this script can assume the calculator is checkpointed.
#
# OUTPUTS:
#   properties -- dictionary of key/value pairs corresponding
#     to physical quantities computed by this test

# standard ASE structure generation routines
from ase.lattice.cubic import BodyCenteredCubic
from ase.calculators.neighborlist import NeighborList
from numpy import dot, sum, amax
from math import sqrt

from quippy import Potential

# set of utility routines specific this this model/testing framework
from utilities import relax_atoms, relax_atoms_cell

# the current model
import model

a0 = 3.16 # initial guess at lattice constant, cell will be relaxed below
fmax = 1e-3 # maximum force following relaxtion [eV/A]
N = 3 # number of unit cells in each direction
remove_index = 0 # which atom to remove

if not hasattr(model, 'bulk_reference_216'):
    # set up the a
    bulk = BodyCenteredCubic(symbol='W', latticeconstant=a0)

    # specify that we will use model.calculator to compute forces, energies and stresses
    bulk.set_calculator(model.calculator)

    # use one of the routines from utilities module to relax the initial
    # unit cell and atomic positions
    bulk = relax_atoms_cell(bulk, tol=fmax, traj_file=None)
    bulk *= (N, N, N)
    bulk_energy = bulk.get_potential_energy()
else:
    bulk = model.bulk_reference_216
    bulk_energy = bulk.get_potential_energy()

def vacancy_energy(bulk, remove_index=0):
    Nat = bulk.get_number_of_atoms()
    vac = bulk.copy()
    vac.set_calculator(bulk.get_calculator())

    nl = NeighborList([a0*sqrt(3.0)/4*0.6]*len(bulk), self_interaction=False, bothways=True)
    nl.update(bulk)
    indices, offsets = nl.get_neighbors(remove_index)
    offset_factor=0.13
    for i, offset in zip(indices, offsets):
       ri = vac.positions[remove_index] - (vac.positions[i] + dot(offset, vac.get_cell()))
       vac.positions[i] += offset_factor*ri
       offset_factor += 0.01

    del vac[remove_index] # remove an atom to introduce a vacancy

    # perturb positions
    vac.rattle(0.01)

    ##
    try:
        model.calculator.set(local_gap_error='local_gap_error')
        vac.get_potential_energy()
        unrelaxed_local_gap_error_max = amax(model.calculator.results['local_gap_error'])
        unrelaxed_local_gap_error_sum = sum(model.calculator.results['local_gap_error'])
    except:
        unrelaxed_local_gap_error_max = None
        unrelaxed_local_gap_error_sum = None
    if isinstance(model, Potential):
        model.calculator.set(local_gap_error='')

    # relax atom positions, holding cell fixed
    vac = relax_atoms(vac, tol=fmax, traj_file="model-"+model.name+"-test-vacancy-energy.opt.xyz")

    vac.write("model-"+model.name+"test-vacancy-energy-relaxed.xyz")

    ##
    try:
        model.calculator.set(local_gap_error='local_gap_error')
        vac.get_potential_energy()
        relaxed_local_gap_error_max = amax(model.calculator.results['local_gap_error'])
        relaxed_local_gap_error_sum = sum(model.calculator.results['local_gap_error'])
    except:
        relaxed_local_gap_error_max = None
        relaxed_local_gap_error_sum = None
    if isinstance(model, Potential):
        model.calculator.set(local_gap_error='')
    ##

    # compute vacancy formation energy as difference of bulk and vac energies
    print 'bulk cell energy', bulk_energy
    print 'vacancy cell energy', vac.get_potential_energy()
    e_form = vac.get_potential_energy() - bulk_energy*vac.get_number_of_atoms()/bulk.get_number_of_atoms()
    print 'vacancy formation energy', e_form
    return (e_form, unrelaxed_local_gap_error_max, unrelaxed_local_gap_error_sum, relaxed_local_gap_error_max, relaxed_local_gap_error_sum)

# dictionary of computed properties - this is output of this test, to
#   be compared with other models

(e_form, unrelaxed_local_gap_error_max, unrelaxed_local_gap_error_sum, relaxed_local_gap_error_max, relaxed_local_gap_error_sum) = vacancy_energy(bulk, remove_index=remove_index)
properties = {'vacancy_energy': e_form,
              'vacancy_unrelaxed_local_gap_error_max' : unrelaxed_local_gap_error_max,
              'vacancy_unrelaxed_local_gap_error_sum' : unrelaxed_local_gap_error_sum,
              'vacancy_relaxed_local_gap_error_max' : relaxed_local_gap_error_max,
              'vacancy_relaxed_local_gap_error_sum' : relaxed_local_gap_error_sum }
============================================================
/Users/Cas/.local/lib/python2.7/site-packages/ase/calculators/neighborlist.py:5: UserWarning: Moved to ase.neighborlist
  warnings.warn('Moved to ase.neighborlist')
relax_atoms_cell using method lbfgs_precon
WARNING:ase.optimize.precon:use_pyamg=True but PyAMG cannot be imported! falling back on direct inversion of preconditioner, may be slow for large systems
/Users/Cas/.local/lib/python2.7/site-packages/ase/atoms.py:763: UserWarning: Converting 3x3 stress tensor from JulipCalculator calculator to the required Voigt form.
  'calculator to the required Voigt form.')
PreconLBFGS:   0  12:16:15      -22.380837       0.0000       0.0385
INFO:ase.optimize.precon:estimate_nearest_neighbour_distance(): calling neighbour_list with r_cut=1.00 A
INFO:ase.optimize.precon:estimate_nearest_neighbour_distance(): calling neighbour_list with r_cut=1.62 A
INFO:ase.optimize.precon:estimate_nearest_neighbour_distance(): calling neighbour_list with r_cut=2.62 A
INFO:ase.optimize.precon:estimate_nearest_neighbour_distance(): calling neighbour_list with r_cut=4.24 A
INFO:ase.optimize.precon:estimate_nearest_neighbour_distance(): got r_NN=2.737 in 0.00246810913086 s
INFO:ase.optimize.precon:creating sparse precon: initial_assembly=True, force_stab=False, apply_positions=True, apply_cell=True
INFO:ase.optimize.precon:--- neighbour list created in 0.000178098678589 s ---
INFO:ase.optimize.precon:adding stabilisation to preconditioner
INFO:ase.optimize.precon:--- computed triplet format in 0.000120878219604 s ---
INFO:ase.optimize.precon:--- remove zeros in 4.00543212891e-05 s ---
INFO:ase.optimize.precon:--- created CSC matrix in 0.000649929046631 s ---
INFO:ase.optimize.precon:--- N-dim precon created in 0.000741958618164 s ---
INFO:ase.optimize.precon:estimate_mu(): mu=1.1338948366365749, mu_c=46.75447454769309
INFO:ase.optimize.precon:creating sparse precon: initial_assembly=False, force_stab=False, apply_positions=True, apply_cell=True
INFO:ase.optimize.precon:--- neighbour list created in 0.000115156173706 s ---
INFO:ase.optimize.precon:adding stabilisation to preconditioner
INFO:ase.optimize.precon:--- computed triplet format in 0.000132083892822 s ---
INFO:ase.optimize.precon:--- applied fixed_atoms in 5.50746917725e-05 s ---
INFO:ase.optimize.precon:--- remove zeros in 4.60147857666e-05 s ---
INFO:ase.optimize.precon:--- created CSC matrix in 0.000473022460938 s ---
INFO:ase.optimize.precon:--- N-dim precon created in 0.000759124755859 s ---
INFO:ase.optimize.precon:--- Precon created in 0.00224304199219 seconds ---
INFO:ase.optimize.precon:--- Precon applied in 0.00029993057251 seconds ---
INFO:ase.utils.linesearcharmijo:a1 = 1.000, suff_dec = True
